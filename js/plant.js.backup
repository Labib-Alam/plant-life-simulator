class Plant {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.stage = PLANT_STAGES.SEED;
        this.age = 0; // Age in game days
        this.health = 100;
        this.height = 1;
        this.rootDepth = 1;
        this.lastGrowthCheck = 0;
        this.growthRate = 0.4; // Increased growth rate from 0.2 to 0.4
        this.waterAbsorption = 0.5; // How much water the plant absorbs
        this.nutrientAbsorption = 0.3; // How much nutrients the plant absorbs
        this.lastUpdateTime = 0; // Track last update time
        this.branchCount = 0; // Track number of branches
        this.leafCount = 0; // Track number of leaves
        this.growthCheckInterval = HOUR_LENGTH; // Check growth every hour
        
        // Track branch angles for 90-degree rotation
        this.lastBranchSide = 1; // 1 for right, -1 for left
        
        // Parts of the plant that have grown
        this.parts = {
            roots: [{ x: 0, y: 0, type: PLANT_PARTS.ROOT, size: 5, absorption: [] }],
            stem: [{ x: 0, y: 0, type: PLANT_PARTS.STEM, size: 5, color: '#228B22' }],
            leaves: [],
            branches: [],
            connectors: []
        };
        
        // Immediately grow to make seed visible - make it more prominent
        this.growStem(0, -1, { size: 6, color: '#32CD32' }); // Brighter green and larger
        
        // Add a visible seed structure
        this.parts.connectors.push({
            x: 0, 
            y: -1, 
            type: PLANT_PARTS.CONNECTOR, 
            radius: 5, 
            color: '#8B4513', 
            connections: []
        });
        
        this.stemLeafSide = 1; // Track which side to place stem leaves on
        
        console.log("New plant created at", x, y, "with parts:", JSON.stringify(this.parts));
    }
    
    update(world, gameTime) {
        if (!world) {
            console.error("World object is missing in plant update");
            return false;
        }
        
        // Update plant age
        const daysPassed = Math.floor(gameTime / DAY_LENGTH);
        if (daysPassed > this.age) {
            this.age = daysPassed;
            
            // Force growth check on new day
            this.checkGrowth(world);
            console.log("Plant age updated to", this.age, "days");
        }
        
        // Check for growth based on time interval
        const timeSinceLastUpdate = gameTime - this.lastUpdateTime;
        if (timeSinceLastUpdate > this.growthCheckInterval) {
            this.lastUpdateTime = gameTime;
            
            // Increased chance to grow each hour from 0.2 to 0.5 for better visibility
            if (Math.random() < 0.5) {
                this.checkGrowth(world);
            }
        }
        
        // Check environmental factors
        this.checkEnvironment(world);
        
        return this.health > 0; // Return true if plant is alive
    }
    
    checkGrowth(world) {
        if (!world) return;
        
        // Calculate growth factors
        const moistureFactor = this.calculateMoistureFactor(world);
        const nutrientFactor = this.calculateNutrientFactor(world);
        const sunlightFactor = this.calculateSunlightFactor(world);
        
        // Calculate overall growth potential
        const growthPotential = this.growthRate * moistureFactor * nutrientFactor * sunlightFactor;
        
        // Increase chance of growth for new plants
        let growthChance = growthPotential;
        if (this.stage === PLANT_STAGES.SEED || this.stage === PLANT_STAGES.GERMINATION) {
            growthChance = Math.max(0.8, growthChance); // Increased from 0.7 to 0.8 for early stages
        } else {
            // Ensure other stages also have reasonable growth chance
            growthChance = Math.max(0.5, growthChance); // Increased from 0.4 to 0.5
        }
        
        console.log(`Growth check: Potential=${growthPotential.toFixed(2)}, Chance=${growthChance.toFixed(2)}`);
        
        // Safety check for maximum size
        if (this.height >= 20 || this.rootDepth >= 15) { // Increased max root depth from 10 to 15
            console.log("Plant has reached maximum size");
            return;
        }
        
        // Chance to grow based on potential - now almost guaranteed for testing
        if (Math.random() < growthChance) {
            this.grow(world); // Pass world to grow method
        }
        
        // Always grow at least one part to ensure visibility during testing
        if (this.parts.stem.length < 3 || this.parts.roots.length < 3) {
            this.grow(world);
        }
        
        // Absorb resources from soil
        this.absorbResources(world);
    }
    
    calculateMoistureFactor(world) {
        if (!world) return 0;
        
        // Check moisture in soil around roots
        let totalMoisture = 0;
        let tileCount = 0;
        
        for (const root of this.parts.roots) {
            const rootX = this.x + root.x;
            const rootY = this.y + root.y;
            const tile = world.getTile(rootX, rootY);
            
            if (tile && tile.type !== TILE_TYPES.AIR) {
                totalMoisture += tile.moisture;
                tileCount++;
            }
        }
        
        const avgMoisture = tileCount > 0 ? totalMoisture / tileCount : 0;
        return Math.min(avgMoisture / 50, 1); // Normalize to 0-1
    }
    
    calculateNutrientFactor(world) {
        if (!world) return 0;
        
        // Check nutrients in soil around roots
        let totalNutrients = 0;
        let tileCount = 0;
        
        for (const root of this.parts.roots) {
            const rootX = this.x + root.x;
            const rootY = this.y + root.y;
            const tile = world.getTile(rootX, rootY);
            
            if (tile && tile.type !== TILE_TYPES.AIR) {
                totalNutrients += tile.nutrients;
                tileCount++;
            }
        }
        
        const avgNutrients = tileCount > 0 ? totalNutrients / tileCount : 0;
        return Math.min(avgNutrients / 50, 1); // Normalize to 0-1
    }
    
    calculateSunlightFactor(world) {
        // Simple sunlight factor based on time of day
        const hour = world.currentHour;
        if (hour >= 6 && hour < 18) {
            // Daytime - more sunlight
            return 1 - Math.abs(12 - hour) / 12; // Peak at noon
        } else {
            // Nighttime - minimal growth
            return 0.1;
        }
    }
    
    absorbResources(world) {
        if (!world) return;
        
        // Absorb water and nutrients from surrounding tiles
        for (const root of this.parts.roots) {
            const rootX = this.x + root.x;
            const rootY = this.y + root.y;
            const tile = world.getTile(rootX, rootY);
            
            if (tile && (tile.type === TILE_TYPES.DIRT || tile.type === TILE_TYPES.WATER)) {
                // Absorb moisture
                const waterToAbsorb = Math.min(tile.moisture, this.waterAbsorption);
                tile.moisture = Math.max(0, tile.moisture - waterToAbsorb);
                
                // Absorb nutrients
                if (tile.type === TILE_TYPES.DIRT) {
                    const nutrientsToAbsorb = Math.min(tile.nutrients, this.nutrientAbsorption);
                    tile.nutrients = Math.max(0, tile.nutrients - nutrientsToAbsorb);
                }
            }
        }
    }
    
    grow(world) {
        // Add world parameter to enable setting tile types
        
        // Determine what can grow based on plant stage
        switch (this.stage) {
            case PLANT_STAGES.SEED:
                // Seeds develop roots first
                if (Math.random() < 0.9) { // Increased from 0.8 to 0.9
                    // The first root is always directly down
                    this.growRoot(0, 1, { world: world, size: 4, advanced: false });
                    
                    // Update stage after developing first root
                    this.stage = PLANT_STAGES.GERMINATION;
                    console.log("Plant advanced to germination stage");
                }
                break;
                
            case PLANT_STAGES.GERMINATION:
                // Germinating seeds develop more roots and begin to develop stem
                if (Math.random() < 0.7) {
                    // Grow a stem segment (upward)
                    this.growStem(0, -1, { size: 4, color: '#32CD32' });
                    
                    // Add a simple leaf
                    if (Math.random() < 0.6) {
                        this.growLeaf(0, -1, { leafType: 'cotyledon', size: 1.2 });
                    }
                } else {
                    // Grow more roots
                    const rootX = Math.round(Math.random() * 2 - 1); // -1, 0, or 1
                    const rootY = 1 + Math.floor(Math.random() * 2); // 1 or 2
                    this.growRoot(rootX, rootY, { world: world, size: 4 });
                }
                
                // Progress to sapling stage when we have enough roots and stem
                if (this.parts.roots.length >= 2 && this.parts.stem.length >= 2) {
                    this.stage = PLANT_STAGES.SAPLING;
                    console.log("Plant advanced to sapling stage");
                }
                break;
                
            case PLANT_STAGES.SAPLING:
                // Saplings develop more stem and leaves, and continue root growth
                const growth = Math.random();
                
                if (growth < 0.4) {
                    // Grow stem (upward) with increasing complexity
                    const stemY = -this.parts.stem.length - 1;
                    this.growStem(0, stemY, { size: 4.5, color: '#32CD32' });
                    
                    // Add leaves to stem - but only if we don't already have too many
                    if (Math.random() < 0.5 && this.leafCount < 25) { // Reduced probability and added count check
                        // Alternate sides for leaves on stem
                        const leafX = (this.stemLeafSide || 1) * (0.7 + Math.random() * 0.3);
                        this.growLeaf(leafX, stemY, { 
                            leafType: 'simple', 
                            size: 1.2,
                            angle: leafX > 0 ? Math.PI/4 : -Math.PI/4 // Orient based on side
                        });
                        // Flip the side for next leaf
                        this.stemLeafSide = (this.stemLeafSide || 1) * -1;
                    }
                } else if (growth < 0.8) {
                    // Grow roots with increased complexity
                    const rootX = Math.round(Math.random() * 4 - 2); // -2 to 2
                    const rootY = Math.floor(Math.random() * 3) + this.rootDepth; // deeper roots
                    
                    this.growRoot(rootX, rootY, { 
                        world: world,
                        advanced: Math.random() < 0.3,
                        size: 4.5
                    });
                } else {
                    // Grow branches
                    if (this.parts.stem.length > 3) {
                        const branchY = -Math.floor(Math.random() * (this.parts.stem.length - 1)) - 1;
                        const branchX = this.lastBranchSide;
                        
                        this.growBranch(branchX, branchY, { size: 3.5 });
                        
                        // Alternate branch sides
                        this.lastBranchSide *= -1;
                    }
                }
                
                // Progress to juvenile stage with enough growth
                if (this.parts.stem.length >= 4 && this.parts.roots.length >= 5) {
                    this.stage = PLANT_STAGES.JUVENILE;
                    console.log("Plant advanced to juvenile stage");
                }
                break;
                
            case PLANT_STAGES.JUVENILE:
                // Juvenile plants develop more complex structures
                const juvGrowth = Math.random();
                
                if (juvGrowth < 0.3) {
                    // Continue stem growth
                    const stemY = -this.parts.stem.length - 1;
                    this.growStem(0, stemY, { size: 5, color: '#228B22' });
                    
                    // Add more complex leaves - with count limit to prevent overcrowding
                    if (Math.random() < 0.6 && this.leafCount < 35) { // Reduced probability and added count check
                        // Alternate sides with random offset
                        const leafX = (this.stemLeafSide || 1) * (0.8 + Math.random() * 0.4);
                        this.growLeaf(leafX, stemY, { 
                            leafType: Math.random() < 0.6 ? 'detailed' : 'simple',
                            size: 1.4,
                            angle: leafX > 0 ? Math.PI/4 : -Math.PI/4 // Orient based on side
                        });
                        // Flip the side for next leaf
                        this.stemLeafSide = (this.stemLeafSide || 1) * -1;
                    }
                } else if (juvGrowth < 0.6) {
                    // 30% chance for more complex root system
                    const rootX = Math.round(Math.random() * 6 - 3); // -3 to 3
                    const rootY = Math.floor(Math.random() * 4) + this.rootDepth; // deeper roots
                    
                    this.growRoot(rootX, rootY, { 
                        world: world,
                        advanced: true, // Always create advanced roots in juvenile stage
                        size: 5
                    });
                } else {
                    // More branches and sub-branches
                    if (this.parts.stem.length > 3) {
                        if (this.parts.branches.length < 4 || Math.random() < 0.5) {
                            // New branch
                            const branchY = -Math.floor(Math.random() * (this.parts.stem.length - 1)) - 1;
                            const branchX = this.lastBranchSide;
                            
                            const branch = this.growBranch(branchX, branchY, { size: 4 });
                            
                            // Add leaves to branch
                            if (branch && Math.random() < 0.7) {
                                // Add slight offset to leaf position to avoid exact branch endpoint
                                const leafOffsetX = branch.x + (Math.random() * 0.3 - 0.15);
                                const leafOffsetY = branch.y + (Math.random() * 0.3 - 0.15);
                                
                                this.growLeaf(leafOffsetX, leafOffsetY, { 
                                    leafType: 'detailed',
                                    size: 1.3,
                                    // Calculate angle based on branch direction to orient leaf properly
                                    angle: branch.x > 0 ? Math.PI/4 : -Math.PI/4,
                                    branch: branch 
                                });
                            }
                            
                            // Alternate branch sides
                            this.lastBranchSide *= -1;
                        } else if (this.parts.branches.length > 0) {
                            // Add sub-branch to existing branch
                            const branchIndex = Math.floor(Math.random() * this.parts.branches.length);
                            const branch = this.parts.branches[branchIndex];
                            
                            if (branch && (!branch.subBranches || branch.subBranches.length < 2)) {
                                const subBranchX = branch.x + (Math.random() > 0.5 ? 1 : -1);
                                const subBranchY = branch.y - 1;
                                
                                const subBranch = this.growSubBranch(subBranchX, subBranchY, branch);
                                
                                // Add leaves to sub-branch
                                if (subBranch && Math.random() < 0.8) {
                                    // Add slight offset to leaf position to avoid exact branch endpoint
                                    const leafOffsetX = subBranch.x + (Math.random() * 0.2 - 0.1);
                                    const leafOffsetY = subBranch.y + (Math.random() * 0.2 - 0.1);
                                    
                                    this.growLeaf(leafOffsetX, leafOffsetY, { 
                                        leafType: 'compound',
                                        size: 1.3,
                                        // Calculate angle based on branch direction to orient leaf properly
                                        angle: subBranch.x > subBranch.startX ? Math.PI/4 : -Math.PI/4,
                                        branch: subBranch 
                                    });
                                }
                            }
                        }
                    }
                }
                
                // Progress to advanced stage with enough complexity
                if (this.parts.stem.length >= 7 && 
                    this.parts.branches.length >= 2 && 
                    this.parts.roots.length >= 8) {
                    this.stage = PLANT_STAGES.ADVANCED;
                    console.log("Plant advanced to advanced stage");
                }
                break;
                
            case PLANT_STAGES.ADVANCED:
                // Advanced plants develop most complex structures
                const advGrowth = Math.random();
                
                if (advGrowth < 0.3) {
                    // Continue stem growth with woody texture
                    const stemY = -this.parts.stem.length - 1;
                    this.growStem(0, stemY, { size: 5.5, color: '#8B4513', woody: true });
                    
                    // Add compound leaves
                    if (Math.random() < 0.5) {
                        this.growLeaf(0, stemY, { 
                            leafType: 'compound',
                            size: 2,
                            advanced: true 
                        });
                    }
                } else if (advGrowth < 0.5) {
                    // Complex root system
                    const rootX = Math.round(Math.random() * 8 - 4); // -4 to 4
                    const rootY = Math.floor(Math.random() * 5) + this.rootDepth; // even deeper roots
                    
                    this.growRoot(rootX, rootY, { 
                        world: world,
                        advanced: true, 
                        complex: true,
                        size: 5.5
                    });
                } else {
                    // Complex branch structures
                    if (this.parts.branches.length > 0) {
                        const branchOrSubbranch = Math.random();
                        
                        if (branchOrSubbranch < 0.3 && this.parts.branches.length < 6) {
                            // New main branch
                            const branchY = -Math.floor(Math.random() * (this.parts.stem.length - 1)) - 1;
                            const branchX = this.lastBranchSide * (1 + Math.floor(Math.random() * 1));
                            
                            const branch = this.growBranch(branchX, branchY, { 
                                size: 4.5, 
                                woody: true,
                                color: '#8B4513'
                            });
                            
                            if (branch && Math.random() < 0.7) {
                                // Add slight offset to leaf position to avoid exact branch endpoint
                                const leafOffsetX = branch.x + (Math.random() * 0.3 - 0.15);
                                const leafOffsetY = branch.y + (Math.random() * 0.3 - 0.15);
                                
                                this.growLeaf(leafOffsetX, leafOffsetY, { 
                                    leafType: 'compound',
                                    size: 1.3,
                                    // Calculate angle based on branch direction to orient leaf properly
                                    angle: branch.x > 0 ? Math.PI/4 : -Math.PI/4,
                                    branch: branch 
                                });
                            }
                            
                            this.lastBranchSide *= -1;
                        } else if (branchOrSubbranch < 0.7) {
                            // Add sub-branch
                            const branchIndex = Math.floor(Math.random() * this.parts.branches.length);
                            const branch = this.parts.branches[branchIndex];
                            
                            if (branch) {
                                const subBranchX = branch.x + (Math.random() > 0.5 ? 1 : -1);
                                const subBranchY = branch.y - 1;
                                
                                const subBranch = this.growSubBranch(subBranchX, subBranchY, branch);
                                
                                if (subBranch && Math.random() < 0.7) {
                                    // Add slight offset to leaf position to avoid exact branch endpoint
                                    const leafOffsetX = subBranch.x + (Math.random() * 0.2 - 0.1);
                                    const leafOffsetY = subBranch.y + (Math.random() * 0.2 - 0.1);
                                    
                                    this.growLeaf(leafOffsetX, leafOffsetY, { 
                                        leafType: 'compound',
                                        size: 1.3,
                                        // Calculate angle based on branch direction to orient leaf properly
                                        angle: subBranch.x > subBranch.startX ? Math.PI/4 : -Math.PI/4,
                                        branch: subBranch 
                                    });
                                }
                            }
                        } else {
                            // Find a sub-branch and add tertiary branch
                            const branchIndex = Math.floor(Math.random() * this.parts.branches.length);
                            const branch = this.parts.branches[branchIndex];
                            
                            if (branch && branch.subBranches && branch.subBranches.length > 0) {
                                const subBranchIndex = Math.floor(Math.random() * branch.subBranches.length);
                                const subBranch = branch.subBranches[subBranchIndex];
                                
                                if (subBranch) {
                                    const tertiaryX = subBranch.x + (Math.random() > 0.5 ? 1 : -1);
                                    const tertiaryY = subBranch.y - 1;
                                    
                                    const tertiaryBranch = this.growTertiaryBranch(tertiaryX, tertiaryY, subBranch);
                                    
                                    if (tertiaryBranch && Math.random() < 0.8) {
                                        // Add slight offset to leaf position to avoid exact branch endpoint
                                        const leafOffsetX = tertiaryBranch.x + (Math.random() * 0.3 - 0.15);
                                        const leafOffsetY = tertiaryBranch.y + (Math.random() * 0.3 - 0.15);
                                        
                                        this.growLeaf(leafOffsetX, leafOffsetY, { 
                                            leafType: 'compound',
                                            size: 1.3,
                                            // Calculate angle based on branch direction to orient leaf properly
                                            angle: tertiaryBranch.x > tertiaryBranch.startX ? Math.PI/4 : -Math.PI/4,
                                            branch: tertiaryBranch 
                                        });
                                    }
                                }
                            }
                        }
                    } else {
                        // If no branches yet, add one
                        const branchY = -Math.floor(Math.random() * (this.parts.stem.length - 1)) - 1;
                        const branchX = this.lastBranchSide;
                        
                        this.growBranch(branchX, branchY, { size: 4 });
                        this.lastBranchSide *= -1;
                    }
                }
                
                break;
        }
    }
    
    growStem(dx, dy, options = {}) {
        // Calculate new position
        const newX = dx;
        const newY = dy;
        
        // Check if stem already exists at this position
        const existingStem = this.parts.stem.find(stem => stem.x === newX && stem.y === newY);
        if (existingStem) {
            // Just update existing stem if found
            if (options.size) {
                existingStem.size = options.size;
            }
            if (options.color) {
                existingStem.color = options.color;
            }
            console.log("Updated existing stem at", newX, newY);
            return existingStem;
        }
        
        // Create new stem segment with options
        const stemSize = options.size || 5; // Default to larger size
        const stemColor = options.color || (this.stage >= PLANT_STAGES.JUVENILE ? '#8B4513' : '#32CD32');
        
        const stem = {
            x: newX,
            y: newY,
            type: PLANT_PARTS.STEM,
            size: stemSize,
            color: stemColor,
            curved: options.curved || false,
            connectionPoints: [] // Add connection points array for stem
        };
        
        // Generate connection points for stem - one on each side
        if (this.stage >= PLANT_STAGES.GERMINATION) {
            // Left side connection point
            stem.connectionPoints.push({
                side: -1, // -1 for left, 1 for right
                position: Math.random() * 0.4 + 0.3, // Position 30-70% down the stem segment
                occupied: false,
                leafId: null
            });
            
            // Right side connection point
            stem.connectionPoints.push({
                side: 1, // 1 for right
                position: Math.random() * 0.4 + 0.3, // Position 30-70% down the stem segment
                occupied: false,
                leafId: null
            });
        }
        
        // Add to plant parts
        this.parts.stem.push(stem);
        
        // Update plant height
        if (newY < 0 && Math.abs(newY) > this.height) {
            this.height = Math.abs(newY);
        }
        
        console.log("Grew stem at", newX, newY, "with color", stemColor);
        
        // Chance to immediately add a leaf at one of the connection points
        if (this.stage >= PLANT_STAGES.GERMINATION && stem.connectionPoints.length > 0 && Math.random() < 0.6 && this.leafCount < 40) {
            // Choose which side to place leaf on
            const sideToUse = this.stemLeafSide || 1;
            const connectionPoint = stem.connectionPoints.find(cp => cp.side === sideToUse && !cp.occupied);
            
            if (connectionPoint) {
                // Calculate leaf position
                const leafX = newX + connectionPoint.side * 0.7; // Offset to side
                const leafY = newY + connectionPoint.position - 0.5; // Position along stem segment
                
                // Determine leaf type based on plant stage
                let leafType = 'simple';
                if (this.stage >= PLANT_STAGES.JUVENILE) {
                    leafType = Math.random() < 0.6 ? 'detailed' : 'simple';
                }
                if (this.stage >= PLANT_STAGES.ADVANCED) {
                    leafType = Math.random() < 0.5 ? 'compound' : 'detailed';
                }
                
                const leaf = this.growLeaf(leafX, leafY, { 
                    leafType: leafType,
                    size: 1.3,
                    angle: connectionPoint.side > 0 ? Math.PI/4 : -Math.PI/4, // Orient based on side
                    branch: stem,
                    connectionPoint: connectionPoint,
                    isStemLeaf: true
                });
                
                // Mark connection point as occupied
                if (leaf) {
                    connectionPoint.occupied = true;
                    connectionPoint.leafId = this.leafCount - 1;
                    
                    // Flip side for next leaf
                    this.stemLeafSide = (this.stemLeafSide || 1) * -1;
                }
            }
        }
        
        return stem;
    }
    
    growRoot(dx, dy, options = {}) {
        // Check for world parameter
        const world = options.world;
        
        // Calculate world coordinates
        const worldX = this.x + dx;
        const worldY = this.y + dy;
        
        // Verify if we can grow here (check world bounds and tile type)
        if (world) {
            const tile = world.getTile(worldX, worldY);
            if (tile) {
                // If tile is stone, we can't grow there
                if (tile.type === TILE_TYPES.STONE) {
                    console.log("Cannot grow root in stone at", worldX, worldY);
                    return null;
                }
                
                // Set the tile to ROOT type to make it visually distinct in the world
                tile.type = TILE_TYPES.ROOT;
                console.log("Set tile type to ROOT at", worldX, worldY);
            }
        }
        
        // Get neighboring tiles to determine best growth direction
        const neighbors = this.getNeighbors(worldX, worldY, 1, world);
        
        // Score neighboring tiles based on moisture, nutrients, and distance from other roots
        const neighborScores = [];
        
        neighbors.forEach(neighbor => {
            if (!neighbor) return;
            
            let score = 0;
            
            // Prefer moist tiles
            if (neighbor.moisture > 50) {
                score += neighbor.moisture / 10;
            }
            
            // Prefer nutrient-rich tiles
            if (neighbor.nutrients > 50) {
                score += neighbor.nutrients / 10;
            }
            
            // Prefer tiles without existing roots
            if (neighbor.type !== TILE_TYPES.ROOT) {
                score += 5;
            }
            
            // Slightly prefer downward growth
            if (neighbor.y > worldY) {
                score += 3;
            }
            
            // Encourage spreading outward
            const distanceFromBase = Math.sqrt(
                Math.pow(neighbor.x - this.x, 2) + 
                Math.pow(neighbor.y - this.y, 2)
            );
            score += distanceFromBase * 2;
            
            neighborScores.push({
                x: neighbor.x - this.x,
                y: neighbor.y - this.y,
                score: score
            });
        });
        
        // Sort neighbors by score
        neighborScores.sort((a, b) => b.score - a.score);
        
        // Check if root already exists at this position
        const existingRoot = this.parts.roots.find(root => root.x === dx && root.y === dy);
        if (existingRoot) {
            // Root already exists, just update its properties
            if (options.size) {
                existingRoot.size = options.size;
            }
            if (options.color) {
                existingRoot.color = options.color;
            }
            console.log("Updated existing root at", dx, dy);
            return existingRoot;
        }
        
        // Create new root
        const rootSize = options.advanced ? 6 : (options.size || 4); // Larger roots
        const rootColor = options.advanced ? '#8B6914' : (options.color || COLORS.PLANT_ROOT);
        
        const root = {
            x: dx,
            y: dy,
            type: PLANT_PARTS.ROOT,
            size: rootSize,
            color: rootColor,
            absorption: []
        };
        
        // Add absorption zones for advanced roots
        if (options.advanced) {
            const zoneSize = 3 + Math.floor(Math.random() * 3); // 3-5 zones
            const zoneRadius = 1;
            
            for (let i = 0; i < zoneSize; i++) {
                const angle = (Math.PI * 2 / zoneSize) * i;
                const zoneX = Math.cos(angle) * zoneRadius;
                const zoneY = Math.sin(angle) * zoneRadius;
                
                root.absorption.push({
                    x: zoneX,
                    y: zoneY,
                    size: 4 + Math.random() * 2,
                    efficiency: 0.5 + Math.random() * 0.5
                });
            }
        }
        
        // Add to plant parts
        this.parts.roots.push(root);
        
        // Update root depth
        if (dy > 0 && dy > this.rootDepth) {
            this.rootDepth = dy;
        }
        
        console.log("Grew root at", dx, dy, "with color", rootColor);
        
        // Chance to grow another root in a different direction
        if (options.advanced && neighborScores.length > 0 && Math.random() < 0.6) {
            // Grow another root using one of the top 3 scored positions
            const nextIndex = Math.min(1, neighborScores.length - 1);
            const nextRoot = neighborScores[nextIndex];
            
            if (nextRoot && (nextRoot.x !== dx || nextRoot.y !== dy)) {
                setTimeout(() => {
                    this.growRoot(nextRoot.x, nextRoot.y, { 
                        world: world, 
                        advanced: Math.random() < 0.3,
                        size: rootSize - 1
                    });
                }, 0);
            }
        }
        
        // Chance to grow a third root for advanced root systems
        if (options.advanced && neighborScores.length > 2 && Math.random() < 0.4) {
            const thirdIndex = Math.min(2, neighborScores.length - 1);
            const thirdRoot = neighborScores[thirdIndex];
            
            if (thirdRoot && (thirdRoot.x !== dx || thirdRoot.y !== dy)) {
                setTimeout(() => {
                    this.growRoot(thirdRoot.x, thirdRoot.y, { 
                        world: world, 
                        advanced: false,
                        size: rootSize - 2
                    });
                }, 0);
            }
        }
        
        return root;
    }
    
    // Fix the getNeighbors method to properly accept world parameter
    getNeighbors(worldX, worldY, radius = 1, world) {
        if (!world) return [];
        
        const neighbors = [];
        
        // Check surrounding tiles in specified radius
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                // Skip the center tile
                if (dx === 0 && dy === 0) continue;
                
                const nx = worldX + dx;
                const ny = worldY + dy;
                
                const tile = world.getTile(nx, ny);
                if (tile) {
                    neighbors.push(tile);
                }
            }
        }
        
        return neighbors;
    }
    
    growLeaf(dx, dy, options = {}) {
        // Determine if a leaf already exists near this position to avoid overlapping
        const nearbyLeaf = this.parts.leaves.find(existingLeaf => 
            Math.abs(existingLeaf.x - dx) < 0.5 && 
            Math.abs(existingLeaf.y - dy) < 0.5
        );
        
        // If there's already a leaf nearby, offset the position slightly
        if (nearbyLeaf) {
            // Randomize the position slightly to avoid perfect overlap
            dx += (Math.random() * 0.4 - 0.2);
            dy += (Math.random() * 0.4 - 0.2);
        }
        
        // Create new leaf with enhanced visual properties and clear branch attachment
        const leaf = {
            x: dx,
            y: dy,
            type: PLANT_PARTS.LEAF,
            leafType: options.leafType || 'simple',
            size: options.size || 1.0, // Reduced from 1.2 to make smaller
            advanced: options.advanced || false,
            color: options.color || '#32CD32', // Default to bright green
            angle: options.angle || (Math.random() * Math.PI - Math.PI/2), // Full range rotation for variety
            stemLength: options.stemLength || (0.3 + Math.random() * 0.2) // Add stem length for attachment
        };
        
        // If attached to a branch, store reference
        if (options.branch) {
            leaf.branchRef = options.branch;
            
            // If attached to a specific connection point, store that reference
            if (options.connectionPoint) {
                leaf.connectionPoint = options.connectionPoint;
            }
            
            // Add a visible leaf connector to the branch
            this.parts.connectors.push({
                x: dx,
                y: dy,
                color: '#3A5F0B',
                radius: leaf.size * 0.2,
                isLeafConnector: true,
                connections: [
                    { startX: -5, startY: 0, endX: 5, endY: 0 }
                ]
            });
        }
        
        this.parts.leaves.push(leaf);
        this.leafCount += 1;
        
        console.log(`Grew ${leaf.leafType} leaf at (${dx}, ${dy})`);
        
        return leaf;
    }
    
    growBranch(dx, dy, options = {}) {
        const branchSize = 3 + this.stage * 0.8; // Increased size for visibility
        const branch = {
            startX: 0,
            x: dx,
            y: dy,
            type: PLANT_PARTS.BRANCH,
            size: branchSize,
            subBranches: [],
            leafPositions: [], // Track where leaves are placed
            connectionPoints: [] // Add an array to store connection points for leaves
        };
        
        if (options.complex || options.advanced) {
            branch.complex = true;
        }
        
        // Calculate a random angle for the branch if none provided
        branch.angle = options.angle || (dx > 0 ? Math.PI/4 : -Math.PI/4) + (Math.random() * 0.2 - 0.1);
        
        // Generate connection points along the branch
        const connectionPointCount = 2 + Math.floor(Math.random() * 3); // 2-4 connection points
        for (let i = 0; i < connectionPointCount; i++) {
            const t = (i + 1) / (connectionPointCount + 1); // Distribute evenly along branch
            const connectionPoint = {
                t: t, // Position along branch (0-1)
                occupied: false, // Whether a leaf is attached here
                leafId: null // ID of attached leaf (if any)
            };
            branch.connectionPoints.push(connectionPoint);
        }
        
        this.parts.branches.push(branch);
        
        // Add branch connector with better color based on plant stage
        const connectorColor = this.stage >= PLANT_STAGES.MATURE ? COLORS.PLANT_BRANCH : COLORS.PLANT_BRANCH_YOUNG;
        this.parts.connectors.push({
            x: 0,
            y: dy,
            color: connectorColor,
            radius: branchSize * 0.6,
            connections: [
                { startX: -15, startY: 0, endX: 15, endY: 0 },
                { startX: 0, startY: -15, endX: 0, endY: 15 }
            ]
        });
        
        // Have a chance to immediately add a leaf - but only if plant doesn't have too many
        if (options.addLeaf !== false && Math.random() < 0.8 && this.leafCount < 40) {
            // Get first available connection point
            const connectionPoint = branch.connectionPoints.find(cp => !cp.occupied);
            
            if (connectionPoint) {
                // Calculate position based on connection point's t value
                const t = connectionPoint.t;
                
                // Calculate position using quadratic bezier formula
                const startX = 0;
                const startY = dy;
                const controlX = dx/2;
                const controlY = dy - Math.abs(dx) * 0.2;
                const endX = dx;
                const endY = dy;
                
                const leafX = Math.pow(1-t, 2) * startX + 2 * (1-t) * t * controlX + Math.pow(t, 2) * endX;
                const leafY = Math.pow(1-t, 2) * startY + 2 * (1-t) * t * controlY + Math.pow(t, 2) * endY;
                
                // Choose leaf type based on plant stage
                let leafType = 'simple';
                if (this.stage >= PLANT_STAGES.JUVENILE) {
                    leafType = Math.random() < 0.6 ? 'detailed' : 'simple';
                }
                if (this.stage >= PLANT_STAGES.ADVANCED) {
                    leafType = Math.random() < 0.7 ? 'compound' : 'detailed';
                }
                
                const leaf = this.growLeaf(leafX, leafY, { 
                    leafType: leafType,
                    size: 1.3,
                    angle: dx > 0 ? Math.PI/4 : -Math.PI/4, // Orient based on branch direction
                    branch: branch,
                    connectionPoint: connectionPoint
                });
                
                // Mark the connection point as occupied
                if (leaf) {
                    connectionPoint.occupied = true;
                    connectionPoint.leafId = this.leafCount - 1; // ID is index in leaves array
                    branch.leafPositions.push({x: leafX - dx, y: leafY - dy});
                }
            }
        }
        
        return branch;
    }
    
    growSubBranch(dx, dy, parentBranch) {
        if (!parentBranch) return null;
        
        const subBranch = {
            startX: parentBranch.x,
            x: parentBranch.x + dx,
            y: dy,
            type: PLANT_PARTS.BRANCH,
            size: parentBranch.size * 0.7,
            direction: Math.sign(dx),
            connectionPoints: [] // Add connection points array
        };
        
        // Generate connection points along the sub-branch
        const connectionPointCount = 1 + Math.floor(Math.random() * 2); // 1-2 connection points
        for (let i = 0; i < connectionPointCount; i++) {
            const t = (i + 1) / (connectionPointCount + 1); // Distribute evenly along branch
            const connectionPoint = {
                t: t, // Position along branch (0-1)
                occupied: false, // Whether a leaf is attached here
                leafId: null // ID of attached leaf (if any)
            };
            subBranch.connectionPoints.push(connectionPoint);
        }
        
        parentBranch.subBranches.push(subBranch);
        
        // Add Y-branch connector
        this.parts.connectors.push({
            x: parentBranch.x,
            y: dy,
            color: this.stage >= PLANT_STAGES.MATURE ? '#8B4513' : '#228B22',
            radius: subBranch.size * 0.6,
            connections: [
                { startX: 0, startY: -20, endX: 0, endY: 0 },
                { startX: 0, startY: 0, endX: -20, endY: 20 },
                { startX: 0, startY: 0, endX: 20, endY: 20 }
            ]
        });
        
        // Have a chance to add a leaf at one of the connection points
        if (Math.random() < 0.7 && this.leafCount < 40) {
            // Get first available connection point
            const connectionPoint = subBranch.connectionPoints.find(cp => !cp.occupied);
            
            if (connectionPoint) {
                // Calculate position based on connection point's t value
                const t = connectionPoint.t;
                
                // Calculate position using quadratic bezier formula
                const startX = parentBranch.x;
                const startY = dy;
                const controlX = startX + dx/2;
                const controlY = startY - Math.abs(dx) * 0.15;
                const endX = parentBranch.x + dx;
                const endY = dy;
                
                const leafX = Math.pow(1-t, 2) * startX + 2 * (1-t) * t * controlX + Math.pow(t, 2) * endX;
                const leafY = Math.pow(1-t, 2) * startY + 2 * (1-t) * t * controlY + Math.pow(t, 2) * endY;
                
                const leaf = this.growLeaf(leafX, leafY, { 
                    leafType: Math.random() < 0.6 ? 'detailed' : 'simple',
                    size: 1.3,
                    angle: subBranch.x > subBranch.startX ? Math.PI/4 : -Math.PI/4,
                    branch: subBranch,
                    connectionPoint: connectionPoint
                });
                
                // Mark the connection point as occupied
                if (leaf) {
                    connectionPoint.occupied = true;
                    connectionPoint.leafId = this.leafCount - 1;
                }
            }
        }
        
        return subBranch;
    }
    
    growTertiaryBranch(dx, dy, parentSubBranch) {
        if (!parentSubBranch) return null;
        
        const tertiaryBranch = {
            startX: parentSubBranch.x,
            x: parentSubBranch.x + dx,
            y: dy,
            type: PLANT_PARTS.BRANCH,
            size: parentSubBranch.size * 0.6,
            direction: Math.sign(dx),
            connectionPoints: [] // Add connection points array
        };
        
        // Generate connection points along the tertiary branch
        const connectionPointCount = 1; // Just 1 connection point for tertiary branches
        for (let i = 0; i < connectionPointCount; i++) {
            const t = 0.6; // Position it at 60% along the branch
            const connectionPoint = {
                t: t,
                occupied: false,
                leafId: null
            };
            tertiaryBranch.connectionPoints.push(connectionPoint);
        }
        
        if (!parentSubBranch.tertiaryBranches) {
            parentSubBranch.tertiaryBranches = [];
        }
        parentSubBranch.tertiaryBranches.push(tertiaryBranch);
        
        // Have a chance to add a leaf at the connection point
        if (Math.random() < 0.8 && this.leafCount < 40) {
            const connectionPoint = tertiaryBranch.connectionPoints[0]; // Only one connection point
            
            if (connectionPoint) {
                // Calculate leaf position - linear interpolation for tertiary branch
                const leafX = parentSubBranch.x + dx * connectionPoint.t;
                const leafY = dy;
                
                const leaf = this.growLeaf(leafX, leafY, { 
                    leafType: 'simple',
                    size: 1.2,
                    angle: tertiaryBranch.x > tertiaryBranch.startX ? Math.PI/4 : -Math.PI/4,
                    branch: tertiaryBranch,
                    connectionPoint: connectionPoint
                });
                
                // Mark the connection point as occupied
                if (leaf) {
                    connectionPoint.occupied = true;
                    connectionPoint.leafId = this.leafCount - 1;
                }
            }
        }
        
        return tertiaryBranch;
    }
    
    checkEnvironment(world) {
        if (!world) return false;
        
        // Check if plant has enough water and nutrients
        const moistureFactor = this.calculateMoistureFactor(world);
        const nutrientFactor = this.calculateNutrientFactor(world);
        
        // Update health based on environmental factors
        if (moistureFactor < 0.3 || nutrientFactor < 0.3) {
            this.health = Math.max(0, this.health - 0.5); // Plant is suffering
        } else if (moistureFactor > 0.7 && nutrientFactor > 0.7) {
            this.health = Math.min(100, this.health + 0.2); // Plant is thriving
        }
        
        // Plant dies if health reaches 0
        if (this.health <= 0) {
            console.log("Plant has died due to poor environmental conditions");
            return false;
        }
        
        return true;
    }
    
    draw(ctx) {
        console.log("Drawing plant at", this.x, this.y, "with parts:", this.parts.stem.length, "stems,", this.parts.roots.length, "roots");
        
        // Draw roots first
        this.parts.roots.forEach((root, index) => {
            const isRootTip = index === this.parts.roots.length - 1;
            
            // Root color changes based on type and whether it's a tip
            const rootColor = root.color || (isRootTip ? COLORS.PLANT_ROOT_TIP : COLORS.PLANT_ROOT);
            const lineWidth = root.size || (isRootTip ? 6 : 5); // Increased line width for visibility
            
            // Find root parent (the previous root segment)
            const parentIndex = this.findRootParent(root, index);
            const parentRoot = parentIndex >= 0 ? this.parts.roots[parentIndex] : null;
            
            ctx.beginPath();
            ctx.strokeStyle = rootColor;
            ctx.lineWidth = lineWidth;
            
            if (parentRoot) {
                // Draw from parent to this root
                ctx.moveTo(
                    (this.x + parentRoot.x) * TILE_SIZE + TILE_SIZE/2, 
                    (this.y + parentRoot.y) * TILE_SIZE + TILE_SIZE/2
                );
            } else {
                // Draw from plant base
                ctx.moveTo(this.x * TILE_SIZE + TILE_SIZE/2, this.y * TILE_SIZE + TILE_SIZE/2);
            }
            
            // Draw to this root position
            ctx.lineTo(
                (this.x + root.x) * TILE_SIZE + TILE_SIZE/2, 
                (this.y + root.y) * TILE_SIZE + TILE_SIZE/2
            );
            ctx.stroke();
            
            // Draw absorption zones if present, represented as subtle lines instead of circles
            if (root.absorption && root.absorption.length > 0) {
                root.absorption.forEach(zone => {
                    // Calculate position
                    const zoneX = (this.x + root.x + zone.x) * TILE_SIZE + TILE_SIZE/2;
                    const zoneY = (this.y + root.y + zone.y) * TILE_SIZE + TILE_SIZE/2;
                    
                    // Draw small branch lines for absorption instead of circle
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(101, 67, 33, 0.5)'; // Subtle brown color
                    ctx.lineWidth = 1;
                    
                    // Draw 4-6 small branch lines from the zone position
                    const branchCount = 4 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < branchCount; i++) {
                        const angle = (Math.PI * 2 / branchCount) * i;
                        const length = zone.size * 2 + Math.random() * 2;
                        
                        ctx.moveTo(zoneX, zoneY);
                        ctx.lineTo(
                            zoneX + Math.cos(angle) * length,
                            zoneY + Math.sin(angle) * length
                        );
                    }
                    ctx.stroke();
                });
            }
        });
        
        // Draw stem segments
        this.parts.stem.forEach((segment, index) => {
            ctx.beginPath();
            ctx.strokeStyle = segment.color || '#32CD32'; // Default to bright green if no color specified
            ctx.lineWidth = segment.size || 5; // Increased default size
            
            if (segment.curved && index > 0) {
                const prevSegment = this.parts.stem[index - 1];
                const controlX = (this.x + (prevSegment.x + segment.x)/2) * TILE_SIZE + TILE_SIZE/2;
                const controlY = (this.y + prevSegment.y) * TILE_SIZE + TILE_SIZE/2;
                
                ctx.moveTo(
                    (this.x + prevSegment.x) * TILE_SIZE + TILE_SIZE/2,
                    (this.y + prevSegment.y) * TILE_SIZE + TILE_SIZE/2
                );
                ctx.quadraticCurveTo(
                    controlX,
                    controlY,
                    (this.x + segment.x) * TILE_SIZE + TILE_SIZE/2,
                    (this.y + segment.y) * TILE_SIZE + TILE_SIZE/2
                );
            } else {
                ctx.moveTo(
                    (this.x + segment.x) * TILE_SIZE + TILE_SIZE/2,
                    (this.y + segment.y) * TILE_SIZE + TILE_SIZE/2
                );
                ctx.lineTo(
                    (this.x + segment.x) * TILE_SIZE + TILE_SIZE/2,
                    (this.y + segment.y + 1) * TILE_SIZE + TILE_SIZE/2
                );
            }
            ctx.stroke();
            
            // Draw connection points for stem
            if (segment.connectionPoints && segment.connectionPoints.length > 0) {
                segment.connectionPoints.forEach(connectionPoint => {
                    // Calculate position based on connection point's position and side
                    const cpX = (this.x + segment.x + connectionPoint.side * 0.3) * TILE_SIZE + TILE_SIZE/2;
                    const cpY = (this.y + segment.y + connectionPoint.position) * TILE_SIZE + TILE_SIZE/2;
                    
                    // Draw connection point node
                    ctx.beginPath();
                    
                    // Use different colors based on whether point is occupied
                    if (connectionPoint.occupied) {
                        // Occupied node - green indicating leaf attachment
                        ctx.fillStyle = '#3A5F0B'; // Darker green for occupied points
                        ctx.strokeStyle = '#32CD32'; // Bright green outline
                        ctx.lineWidth = 1;
                        ctx.arc(cpX, cpY, segment.size * 0.5, 0, Math.PI * 2);
                    } else {
                        // Available node - light colored to indicate available attachment point
                        ctx.fillStyle = '#8B7355'; // Light brown for available points
                        ctx.strokeStyle = segment.color || '#32CD32';
                        ctx.lineWidth = 1;
                        ctx.arc(cpX, cpY, segment.size * 0.4, 0, Math.PI * 2);
                    }
                    
                    ctx.fill();
                    ctx.stroke();
                });
            }
        });
        
        // Draw branches
        this.parts.branches.forEach(branch => {
            this.drawBranch(ctx, branch);
            
            // Draw sub-branches
            if (branch.subBranches) {
                branch.subBranches.forEach(subBranch => {
                    this.drawSubBranch(ctx, subBranch, branch);
                    
                    // Draw tertiary branches
                    if (subBranch.tertiaryBranches) {
                        subBranch.tertiaryBranches.forEach(tertiaryBranch => {
                            this.drawTertiaryBranch(ctx, tertiaryBranch, subBranch);
                        });
                    }
                });
            }
        });
        
        // Draw leaves
        this.parts.leaves.forEach(leaf => {
            switch (leaf.leafType) {
                case 'cotyledon':
                    this.drawCotyledon(ctx, leaf);
                    break;
                case 'simple':
                    this.drawSimpleLeaf(ctx, leaf);
                    break;
                case 'detailed':
                    this.drawDetailedLeaf(ctx, leaf);
                    break;
                case 'compound':
                    this.drawCompoundLeaf(ctx, leaf);
                    break;
            }
        });
        
        // Draw connectors
        this.parts.connectors.forEach(connector => {
            ctx.beginPath();
            ctx.fillStyle = connector.color;
            ctx.arc(
                (this.x + connector.x) * TILE_SIZE + TILE_SIZE/2,
                (this.y + connector.y) * TILE_SIZE + TILE_SIZE/2,
                connector.radius,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // Draw connection lines
            connector.connections.forEach(connection => {
                ctx.beginPath();
                ctx.strokeStyle = connector.color;
                ctx.lineWidth = connector.radius * 0.5;
                ctx.moveTo(
                    (this.x + connector.x + connection.startX/TILE_SIZE) * TILE_SIZE + TILE_SIZE/2,
                    (this.y + connector.y + connection.startY/TILE_SIZE) * TILE_SIZE + TILE_SIZE/2
                );
                ctx.lineTo(
                    (this.x + connector.x + connection.endX/TILE_SIZE) * TILE_SIZE + TILE_SIZE/2,
                    (this.y + connector.y + connection.endY/TILE_SIZE) * TILE_SIZE + TILE_SIZE/2
                );
                ctx.stroke();
            });
        });
    }
    
    drawBranch(ctx, branch) {
        // Get branch color based on age
        const branchColor = this.stage >= PLANT_STAGES.MATURE ? 
            COLORS.PLANT_BRANCH : COLORS.PLANT_BRANCH_YOUNG;
        
        ctx.beginPath();
        ctx.strokeStyle = branchColor;
        ctx.lineWidth = branch.size;
        
        // Start position (stem connection)
        const startX = (this.x + branch.startX) * TILE_SIZE + TILE_SIZE/2;
        const startY = (this.y + branch.y) * TILE_SIZE + TILE_SIZE/2;
        
        // End position (branch tip)
        const endX = (this.x + branch.x) * TILE_SIZE + TILE_SIZE/2;
        const endY = (this.y + branch.y) * TILE_SIZE + TILE_SIZE/2;
        
        // Calculate control point for curved branch
        // The control point is above the branch to create a slight upward curve
        const controlX = (startX + endX) / 2;
        const controlY = startY - Math.abs(endX - startX) * 0.2;
        
        // Draw the curved branch
        ctx.moveTo(startX, startY);
        ctx.quadraticCurveTo(controlX, controlY, endX, endY);
        ctx.stroke();
        
        // Add branch node at the end (leaf attachment point)
        ctx.beginPath();
        ctx.fillStyle = branchColor;
        ctx.arc(endX, endY, branch.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw connection points along the branch
        if (branch.connectionPoints && branch.connectionPoints.length > 0) {
            branch.connectionPoints.forEach(connectionPoint => {
                // Calculate position using t value and quadratic bezier formula
                const t = connectionPoint.t;
                const cpX = Math.pow(1-t, 2) * startX + 2 * (1-t) * t * controlX + Math.pow(t, 2) * endX;
                const cpY = Math.pow(1-t, 2) * startY + 2 * (1-t) * t * controlY + Math.pow(t, 2) * endY;
                
                // Draw connection point node
                ctx.beginPath();
                
                // Use different colors and sizes based on whether point is occupied
                if (connectionPoint.occupied) {
                    // Occupied node - green/brown indicating leaf attachment
                    ctx.fillStyle = '#3A5F0B'; // Darker green for occupied points
                    ctx.strokeStyle = '#32CD32'; // Bright green outline
                    ctx.lineWidth = 1;
                    ctx.arc(cpX, cpY, branch.size * 0.5, 0, Math.PI * 2);
                } else {
                    // Available node - light colored to indicate available attachment point
                    ctx.fillStyle = '#8B7355'; // Light brown for available points
                    ctx.strokeStyle = branchColor;
                    ctx.lineWidth = 1;
                    ctx.arc(cpX, cpY, branch.size * 0.4, 0, Math.PI * 2);
                }
                
                ctx.fill();
                ctx.stroke();
            });
        }
        
        // If complex branch, add nodes along the branch for detail
        if (branch.complex) {
            const segments = Math.max(2, Math.floor(Math.abs(branch.x - branch.startX) / 0.5));
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                // Quadratic bezier formula: (1-t)P + 2(1-t)tP + tP
                const nodeX = Math.pow(1-t, 2) * startX + 2 * (1-t) * t * controlX + Math.pow(t, 2) * endX;
                const nodeY = Math.pow(1-t, 2) * startY + 2 * (1-t) * t * controlY + Math.pow(t, 2) * endY;
                
                if (Math.random() < 0.7) { // Don't draw every node for natural look
                    ctx.beginPath();
                    ctx.fillStyle = branchColor;
                    ctx.arc(nodeX, nodeY, branch.size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Draw sub-branches
        if (branch.subBranches) {
            branch.subBranches.forEach(subBranch => {
                this.drawSubBranch(ctx, subBranch, branch);
                
                // Draw tertiary branches
                if (subBranch.tertiaryBranches) {
                    subBranch.tertiaryBranches.forEach(tertiaryBranch => {
                        this.drawTertiaryBranch(ctx, tertiaryBranch, subBranch);
                    });
                }
            });
        }
    }
    
    drawSubBranch(ctx, subBranch, parentBranch) {
        // Get branch color based on age
        const branchColor = this.stage >= PLANT_STAGES.MATURE ? 
            COLORS.PLANT_BRANCH : COLORS.PLANT_BRANCH_YOUNG;
        
        ctx.beginPath();
        ctx.strokeStyle = branchColor;
        ctx.lineWidth = subBranch.size;
        
        // Start position (connection to parent branch)
        const startX = (this.x + subBranch.startX) * TILE_SIZE + TILE_SIZE/2;
        const startY = (this.y + subBranch.y) * TILE_SIZE + TILE_SIZE/2;
        
        // End position (branch tip)
        const endX = (this.x + subBranch.x) * TILE_SIZE + TILE_SIZE/2;
        const endY = (this.y + subBranch.y) * TILE_SIZE + TILE_SIZE/2;
        
        // Calculate control point for curved branch
        // For sub-branches, curve should point slightly upward
        const controlX = (startX + endX) / 2;
        const controlY = startY - Math.abs(endX - startX) * 0.15;
        
        // Draw curved sub-branch
        ctx.moveTo(startX, startY);
        ctx.quadraticCurveTo(controlX, controlY, endX, endY);
        ctx.stroke();
        
        // Add node at the branch tip for leaf attachment
        ctx.beginPath();
        ctx.fillStyle = branchColor;
        ctx.arc(endX, endY, subBranch.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw connection points along the sub-branch
        if (subBranch.connectionPoints && subBranch.connectionPoints.length > 0) {
            subBranch.connectionPoints.forEach(connectionPoint => {
                // Calculate position using t value and quadratic bezier formula
                const t = connectionPoint.t;
                const cpX = Math.pow(1-t, 2) * startX + 2 * (1-t) * t * controlX + Math.pow(t, 2) * endX;
                const cpY = Math.pow(1-t, 2) * startY + 2 * (1-t) * t * controlY + Math.pow(t, 2) * endY;
                
                // Draw connection point node
                ctx.beginPath();
                
                // Use different colors and sizes based on whether point is occupied
                if (connectionPoint.occupied) {
                    // Occupied node - green/brown indicating leaf attachment
                    ctx.fillStyle = '#3A5F0B'; // Darker green for occupied points
                    ctx.strokeStyle = '#32CD32'; // Bright green outline
                    ctx.lineWidth = 1;
                    ctx.arc(cpX, cpY, subBranch.size * 0.5, 0, Math.PI * 2);
                } else {
                    // Available node - light colored to indicate available attachment point
                    ctx.fillStyle = '#8B7355'; // Light brown for available points
                    ctx.strokeStyle = branchColor; 
                    ctx.lineWidth = 1;
                    ctx.arc(cpX, cpY, subBranch.size * 0.4, 0, Math.PI * 2);
                }
                
                ctx.fill();
                ctx.stroke();
            });
        }
    }
    
    drawTertiaryBranch(ctx, tertiaryBranch, parentSubBranch) {
        ctx.beginPath();
        ctx.strokeStyle = this.stage >= PLANT_STAGES.MATURE ? '#8B4513' : '#228B22';
        ctx.lineWidth = tertiaryBranch.size;
        
        // Start position
        const startX = (this.x + tertiaryBranch.startX) * TILE_SIZE + TILE_SIZE/2;
        const startY = (this.y + tertiaryBranch.y) * TILE_SIZE + TILE_SIZE/2;
        
        // End position
        const endX = (this.x + tertiaryBranch.x) * TILE_SIZE + TILE_SIZE/2;
        const endY = (this.y + tertiaryBranch.y) * TILE_SIZE + TILE_SIZE/2;
        
        // Draw tertiary branch
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        // Add node at the branch tip
        ctx.beginPath();
        ctx.fillStyle = this.stage >= PLANT_STAGES.MATURE ? '#8B4513' : '#228B22';
        ctx.arc(endX, endY, tertiaryBranch.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw connection points along the tertiary branch
        if (tertiaryBranch.connectionPoints && tertiaryBranch.connectionPoints.length > 0) {
            tertiaryBranch.connectionPoints.forEach(connectionPoint => {
                // Calculate position using t value (linear interpolation for tertiary branches)
                const t = connectionPoint.t;
                const cpX = startX + (endX - startX) * t;
                const cpY = startY + (endY - startY) * t;
                
                // Draw connection point node
                ctx.beginPath();
                
                // Use different colors and sizes based on whether point is occupied
                if (connectionPoint.occupied) {
                    // Occupied node - green/brown indicating leaf attachment
                    ctx.fillStyle = '#3A5F0B'; // Darker green for occupied points
                    ctx.strokeStyle = '#32CD32'; // Bright green outline
                    ctx.lineWidth = 1;
                    ctx.arc(cpX, cpY, tertiaryBranch.size * 0.5, 0, Math.PI * 2);
                } else {
                    // Available node - light colored to indicate available attachment point
                    ctx.fillStyle = '#8B7355'; // Light brown for available points
                    ctx.strokeStyle = this.stage >= PLANT_STAGES.MATURE ? '#8B4513' : '#228B22';
                    ctx.lineWidth = 1;
                    ctx.arc(cpX, cpY, tertiaryBranch.size * 0.4, 0, Math.PI * 2);
                }
                
                ctx.fill();
                ctx.stroke();
            });
        }
    }
    
    drawCotyledon(ctx, leaf) {
        ctx.beginPath();
        ctx.fillStyle = '#90EE90';
        
        // Draw simple oval shape
        const leafWidth = TILE_SIZE/2;
        const leafHeight = TILE_SIZE * 0.75;
        
        ctx.ellipse(
            (this.x + leaf.x) * TILE_SIZE + TILE_SIZE/2,
            (this.y + leaf.y) * TILE_SIZE + TILE_SIZE/2,
            leafWidth,
            leafHeight,
            0,
            0,
            Math.PI * 2
        );
        ctx.fill();
    }
    
    drawSimpleLeaf(ctx, leaf) {
        // Save context for rotation
        ctx.save();
        
        const leafSize = TILE_SIZE * 0.4; // Reduced from 0.6
        const x = (this.x + leaf.x) * TILE_SIZE + TILE_SIZE/2;
        const y = (this.y + leaf.y) * TILE_SIZE + TILE_SIZE/2;
        
        // Translate to leaf position and rotate
        ctx.translate(x, y);
        ctx.rotate(leaf.angle || 0);
        
        // Draw stem connecting to branch if there's a branch reference
        if (leaf.branchRef) {
            ctx.beginPath();
            ctx.strokeStyle = '#3A5F0B'; // Dark green for stem
            ctx.lineWidth = 1.5;
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -leafSize * 0.4); // Stem points toward leaf
            ctx.stroke();
        }
        
        // Draw teardrop shape at origin (0,0) after rotation
        ctx.beginPath();
        ctx.fillStyle = '#228B22';
        
        ctx.moveTo(0, -leafSize);
        ctx.quadraticCurveTo(
            leafSize * 0.7,
            0,
            0,
            leafSize * 0.7
        );
        ctx.quadraticCurveTo(
            -leafSize * 0.7,
            0,
            0,
            -leafSize
        );
        ctx.fill();
        
        // Draw central vein
        ctx.beginPath();
        ctx.strokeStyle = '#1B691B';
        ctx.lineWidth = 1;
        ctx.moveTo(0, -leafSize);
        ctx.lineTo(0, leafSize * 0.7);
        ctx.stroke();
        
        // Restore context to undo rotation and translation
        ctx.restore();
    }
    
    drawDetailedLeaf(ctx, leaf) {
        // Save context for rotation
        ctx.save();
        
        const leafSize = TILE_SIZE * 0.5; // Reduced from 0.75
        const x = (this.x + leaf.x) * TILE_SIZE + TILE_SIZE/2;
        const y = (this.y + leaf.y) * TILE_SIZE + TILE_SIZE/2;
        
        // Translate to leaf position and rotate
        ctx.translate(x, y);
        ctx.rotate(leaf.angle || 0);
        
        // Draw stem connecting to branch if there's a branch reference
        if (leaf.branchRef) {
            ctx.beginPath();
            ctx.strokeStyle = '#3A5F0B'; // Dark green for stem
            ctx.lineWidth = 1.5;
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -leafSize * 0.5); // Stem points toward leaf
            ctx.stroke();
        }
        
        // Main leaf shape at origin after rotation
        ctx.beginPath();
        ctx.fillStyle = '#228B22';
        
        // Main leaf shape
        ctx.moveTo(0, -leafSize);
        ctx.bezierCurveTo(
            leafSize * 0.7,
            -leafSize/2,
            leafSize * 0.7,
            leafSize/2,
            0,
            leafSize * 0.7
        );
        ctx.bezierCurveTo(
            -leafSize * 0.7,
            leafSize/2,
            -leafSize * 0.7,
            -leafSize/2,
            0,
            -leafSize
        );
        ctx.fill();
        
        // Draw veins
        ctx.beginPath();
        ctx.strokeStyle = '#1B691B';
        ctx.lineWidth = 1;
        
        // Main vein
        ctx.moveTo(0, -leafSize);
        ctx.lineTo(0, leafSize * 0.7);
        
        // Side veins
        for (let i = -2; i <= 2; i++) {
            const veinY = i * leafSize/4;
            ctx.moveTo(0, veinY);
            ctx.lineTo(leafSize/2 * Math.sign(i), veinY);
            ctx.moveTo(0, veinY);
            ctx.lineTo(-leafSize/2 * Math.sign(i), veinY);
        }
        ctx.stroke();
        
        // Restore context to undo rotation and translation
        ctx.restore();
    }
    
    drawCompoundLeaf(ctx, leaf) {
        // Save context for rotation
        ctx.save();
        
        // Make compound leaves even smaller to reduce overlap
        const leafletCount = leaf.advanced ? 5 : 3; // Reduced count
        const leafletSize = TILE_SIZE * (leaf.advanced ? 0.35 : 0.25); // Further reduced size
        const spacing = TILE_SIZE * 0.25; // Reduced spacing
        const x = (this.x + leaf.x) * TILE_SIZE + TILE_SIZE/2;
        const y = (this.y + leaf.y) * TILE_SIZE + TILE_SIZE/2;
        
        // Translate to leaf position and rotate the entire compound leaf
        ctx.translate(x, y);
        ctx.rotate(leaf.angle || 0);
        
        // Draw stem connecting to branch if there's a branch reference
        if (leaf.branchRef) {
            ctx.beginPath();
            ctx.strokeStyle = '#3A5F0B'; // Dark green for stem
            ctx.lineWidth = 1.5;
            ctx.moveTo(0, 0);
            ctx.lineTo(-leafletCount/2 * spacing * 0.5, 0); // Stem extends back
            ctx.stroke();
        }
        
        // Draw central leaflet
        this.drawLeaflet(ctx, 0, 0, leafletSize);
        
        // Draw side leaflets with increased angle to spread them out more
        for (let i = 1; i <= Math.floor(leafletCount/2); i++) {
            const offset = i * spacing;
            const angleOffset = Math.PI / 8 * i; // Increased angle for better spread
            
            // Left leaflet
            this.drawLeaflet(ctx, 
                -offset,
                -offset/2, // More vertical offset to spread out
                leafletSize * 0.8,
                -angleOffset // Angle for left side
            );
            // Right leaflet
            this.drawLeaflet(ctx,
                offset,
                -offset/2, // More vertical offset to spread out
                leafletSize * 0.8,
                angleOffset // Angle for right side
            );
        }
        
        // Draw stem connecting leaflets
        ctx.beginPath();
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 1.5;
        ctx.moveTo(-leafletCount/2 * spacing, 0);
        ctx.lineTo(leafletCount/2 * spacing, 0);
        ctx.stroke();
        
        // Restore context to undo rotation and translation
        ctx.restore();
    }
    
    drawLeaflet(ctx, x, y, size, angleOffset = 0) {
        ctx.beginPath();
        ctx.fillStyle = '#32CD32'; // Brighter green for leaflets
        
        // Draw oval leaflet with better detail - small at attachment point, wider at opposite end
        ctx.ellipse(
            x,
            y,
            size * 0.5,
            size * 0.8,
            Math.PI / 4 + angleOffset, // Slightly angled
            0,
            Math.PI * 2
        );
        ctx.fill();
        
        // Add more detailed vein details
        ctx.beginPath();
        ctx.strokeStyle = '#1B691B';
        ctx.lineWidth = 1.5;
        
        // Main vein
        const veinAngle = Math.PI / 4 + angleOffset; // Match the leaflet rotation
        const veinLength = size * 0.8;
        ctx.moveTo(
            x - Math.cos(veinAngle) * veinLength, 
            y - Math.sin(veinAngle) * veinLength
        );
        ctx.lineTo(
            x + Math.cos(veinAngle) * veinLength, 
            y + Math.sin(veinAngle) * veinLength
        );
        ctx.stroke();
    }
    
    // Helper method to find the parent root for a given root
    findRootParent(currentRoot, currentIndex) {
        if (currentIndex === 0) return -1; // Base root has no parent
        
        // Calculate the Manhattan distance to all previous roots
        const distances = [];
        for (let i = 0; i < currentIndex; i++) {
            const prev = this.parts.roots[i];
            const distance = Math.abs(prev.x - currentRoot.x) + Math.abs(prev.y - currentRoot.y);
            distances.push({ index: i, distance });
        }
        
        // Sort by distance (ascending)
        distances.sort((a, b) => a.distance - b.distance);
        
        // Return the index of the closest root
        return distances.length > 0 ? distances[0].index : -1;
    }
} 